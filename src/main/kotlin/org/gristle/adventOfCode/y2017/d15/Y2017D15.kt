package org.gristle.adventOfCode.y2017.d15

import org.gristle.adventOfCode.utilities.elapsedTime
import org.gristle.adventOfCode.utilities.readRawInput

private typealias Generator = Sequence<Short>
class Y2017D15(input: String) {
    private val seeds = Regex("""\d+""").findAll(input).map { it.value.toLong() }.toList()
    private val seedA = seeds[0]
    private val seedB = seeds[1]
    private val factorA = 16807
    private val factorB = 48271

    /* The generators both work on the same principle. To create its next value, a generator will take the previous 
    value it produced, multiply it by a factor (generator A uses 16807; generator B uses 48271), and then keep the 
    remainder of dividing that resulting product by 2147483647. That final remainder is the value it produces next.
        
    To calculate each generator's first value, it instead uses a specific starting value as its "previous value" 
    (as listed in your puzzle input). */
    private fun generator(seed: Long, factor: Int, multiples: Int? = null): Generator =
        generateSequence(seed) { (it * factor) % Int.MAX_VALUE }
            .drop(1) // drop the seed value
            .let { sequence -> // filter for part2 rules (skip for part1)   
                if (multiples == null) sequence else sequence.filter { it % multiples == 0L }
            }.map(Long::toShort) // only look at lowest 16 bits

    /**
     * Used for both parts. Zips the two generator sequences together to create one sequence that generates pairs
     * of values generated by the generators. Returns how often the pairs match given the number of comparisions.
     */
    fun solve(comparisons: Int, generatorA: Generator, generatorB: Generator): Int =
        (generatorA zip generatorB) // join the two Generator sequences together
            .take(comparisons) // number of times the judge compares the generated values
            .count { (aValue, bValue) -> aValue == bValue } // count how many of those values compared are equal

    fun part1() = solve(
        40_000_000,
        generator(seedA, factorA),
        generator(seedB, factorB)
    )

    fun part2() = solve(
        5_000_000,
        generator(seedA, factorA, 4),
        generator(seedB, factorB, 8)
    )
}

fun main() {
    var time = System.nanoTime()
    val c = Y2017D15(readRawInput("y2017/d15"))
    println("Class creation: ${elapsedTime(time)}ms")
    time = System.nanoTime()
    println("Part 1: ${c.part1()} (${elapsedTime(time)}ms)") // 594 
    time = System.nanoTime()
    println("Part 2: ${c.part2()} (${elapsedTime(time)}ms)") // 328
}